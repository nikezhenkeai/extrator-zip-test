<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZIP文件内容提取器 - 本地服务器版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
      :root {
        --primary-color: #3498db;
        --secondary-color: #2980b9;
        --success-color: #2ecc71;
        --warning-color: #f39c12;
        --danger-color: #e74c3c;
        --light-color: #ecf0f1;
        --dark-color: #2c3e50;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        margin: 0;
        padding: 20px;
        min-height: 100px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 30px;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: var(--dark-color);
        margin-bottom: 10px;
      }

      .description {
        color: #666;
        font-size: 1.1em;
      }

      .panels {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }

      .panel {
        flex: 1;
        min-width: 300px;
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .panel-title {
        font-size: 1.3em;
        color: var(--dark-color);
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 2px solid var(--light-color);
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        color: var(--dark-color);
      }

      input,
      select,
      button {
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 5px;
        width: 100%;
        box-sizing: border-box;
        font-size: 1em;
      }

      button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s;
        font-weight: bold;
      }

      button:hover {
        background-color: var(--secondary-color);
      }

      .status {
        padding: 12px;
        border-radius: 5px;
        margin-top: 15px;
        display: none;
      }

      .success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .file-content {
        white-space: pre-wrap;
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        max-height: 400px;
        overflow: auto;
        font-family: monospace;
        font-size: 14px;
        line-height: 1.5;
      }

      .tabs {
        display: flex;
        border-bottom: 1px solid #ddd;
        margin-bottom: 15px;
      }

      .tab {
        padding: 10px 15px;
        cursor: pointer;
        background: #f1f1f1;
        border: 1px solid #ddd;
        border-bottom: none;
        border-radius: 5px 5px 0 0;
        margin-right: 5px;
      }

      .tab.active {
        background: white;
        border-bottom: 1px solid white;
        margin-bottom: -1px;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .progress-bar {
        height: 10px;
        background-color: #f0f0f0;
        border-radius: 5px;
        overflow: hidden;
        margin-top: 10px;
      }

      .progress {
        height: 100%;
        background-color: var(--success-color);
        width: 0%;
        transition: width 0.3s;
      }

      .summary {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin-top: 20px;
      }

      .summary-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px solid #eee;
      }

      footer {
        text-align: center;
        margin-top: 30px;
        color: #666;
        font-size: 0.9em;
      }

      @media (max-width: 768px) {
        .panels {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <button id="test">测试速度</button>
    </div>
    <script src="./test.js"></script>
    <script src="./transform.js"></script>
    <script>
      // analyzeZipStructure()
      const testSmartRangeRequest = async () => {
        try {
          const zipSize = -100000
          const zipUrl = 'http://localhost:3001/test.zip'
          const headResponse = await fetch(zipUrl, {
            headers: { Range: 'bytes=0-3' },
          })
          const headData = await headResponse.arrayBuffer()
          const signature = new Uint8Array(headData)
          const isZip =
            signature[0] === 0x50 &&
            signature[1] === 0x4b &&
            signature[2] === 0x03 &&
            signature[3] === 0x04

          const endSize = Math.min(1024, zipSize)
          const endResponse = await fetch(zipUrl, {
            headers: { Range: `bytes=${zipSize - endSize}-${zipSize - 1}` },
          })
          const endData = await endResponse.arrayBuffer()
          console.log(endResponse, endData, 'endResponse')

          const endView = new Uint8Array(endData)
          let eocdOffset = -1
          // 从末尾开始查找 End of Central Directory 签名 (0x504B0506)
          for (let i = endView.length - 22; i >= 0; i--) {
            if (
              endView[i] === 0x50 &&
              endView[i + 1] === 0x4b &&
              endView[i + 2] === 0x05 &&
              endView[i + 3] === 0x06
            ) {
              eocdOffset = i
              break
            }
          }

          if (eocdOffset >= 0) {
            // 读取条目数量
            const totalEntries =
              endView[eocdOffset + 10] | (endView[eocdOffset + 11] << 8)
            console.log(`✓ ZIP 包含 ${totalEntries} 个条目`)
          } else {
            console.error('⚠ 未找到中央目录结束记录（可能需要更大的读取范围）')
          }

          // // 步骤 4: 为了完整演示，下载完整文件并解压
          // const fullResponse = await fetch(zipUrl)
          // const fullData = await fullResponse.arrayBuffer()

          // const JSZip = (await import('jszip')).default
          // const zip = await JSZip.loadAsync(fullData)
          // const fileNames = Object.keys(zip.files)
        } catch (error) {
          console.error('Smart range request test error:', error)
        }
      }
      let t1, t0
      // 创建多层级目录
      const createDirectoryPath = async (path) => {
        const root = await getOPFSRoot()
        const pathParts = path.split('/').filter((part) => part.length > 0)

        let currentDir = root
        for (const part of pathParts) {
          currentDir = await currentDir.getDirectoryHandle(part, {
            create: true,
          })
        }

        return currentDir
      }
      // 批量保存多个文件到 OPFS
      const saveBatchToOPFS = async (files) => {
        try {
          const totalFiles = files.filter((f) => !f.isDirectory).length
          let processedFiles = 0

          for (const file of files) {
            if (file.isDirectory) {
              console.log(file, 'isDirectory')

              // 创建目录
              await createDirectoryPath(file.path)
            } else {
              // 保存文件
              const pathParts = file.path
                .split('/')
                .filter((part) => part.length > 0)
              const filename = pathParts.pop() || file.path
              const dirPath = pathParts.join('/')

              let targetDir
              if (dirPath) {
                targetDir = await createDirectoryPath(dirPath)
              } else {
                targetDir = await getOPFSRoot()
              }

              const fileHandle = await targetDir.getFileHandle(filename, {
                create: true,
              })
              const writable = await fileHandle.createWritable()
              await writable.write(file.content)
              await writable.close()
            }
          }
          const res = await loadFileList()
          console.log(res, '===批量保存完成===');
          
        } catch (error) {
          console.error('OPFS 批量保存错误:', error)
        }
      }
      // 从 ZIP 解压所有文件到 OPFS
      const extractZipToOPFS = async (zip) => {
        try {
          const fileEntries = Object.entries(zip.files)
          // 准备文件列表
          const extractedFiles = []

          for (let i = 0; i < fileEntries.length; i++) {
            const [path, zipEntry] = fileEntries[i]

            if (zipEntry.dir) {
              // 这是一个目录
              extractedFiles.push({
                path: path.replace(/\/$/, ''), // 移除末尾的斜杠
                content: '',
                isDirectory: true,
              })
            } else {
              // 这是一个文件
              const content = await zipEntry.async('string')
              extractedFiles.push({
                path,
                content,
                isDirectory: false,
              })
            }
          }
          // 批量保存到 OPFS
          await saveBatchToOPFS(extractedFiles)
        } catch (error) {
          console.error('ZIP 解压错误:', error)
        }
      }
      const zipUrl = 'http://localhost:3001/test.zip'
      // 使用JSZip解压数据
      const zip = new JSZip()
      async function testRangeRequest(start, end) {
        const headers = {}
        if (end !== undefined) {
          headers['Range'] = `bytes=${start}-${end}`
        } else {
          headers['Range'] = `bytes=${start}-`
        }

        const response = await fetch(zipUrl, { headers })
        return {
          status: response.status,
          size: response.headers.get('content-length'),
          range: response.headers.get('content-range'),
          data: await response.arrayBuffer(),
        }
      }
      // 获取 OPFS 根目录
      const getOPFSRoot = async () => {
        return await navigator.storage.getDirectory()
      }
      // 从 OPFS 读取文件（支持不同格式）
      const readFromOPFS = async (filename, format = 'text') => {
        t0 = performance.now()
        try {
          const root = await getOPFSRoot()
          const fileHandle = await root.getFileHandle(filename)
          const file = await fileHandle.getFile()
          let content
          // switch (format) {
          //   case 'arrayBuffer':
          //     content = await file.arrayBuffer()
          //     break
          //   case 'blob':
          //     content = file
          //     break
          //   default:
          //     content = await file.text()
          // }
          console.log(filename, 'filename')
          content = await file.arrayBuffer()

          return content
        } catch (error) {
          console.error(error, 'error')

          return null
        }
      }
      // 保存数据到 OPFS（支持二进制和文本数据）
      const saveToOPFS = async (filename, content, options) => {
        try {
          const root = await getOPFSRoot()

          // 创建或获取文件句柄
          const fileHandle = await root.getFileHandle(filename, {
            create: true,
          })

          // 创建可写流
          const writable = await fileHandle.createWritable()

          if (options?.showProgress && content instanceof ArrayBuffer) {
            // 分块写入大文件以支持进度显示
            const chunkSize = 64 * 1024 // 64KB chunks
            const totalSize = content.byteLength

            for (let offset = 0; offset < totalSize; offset += chunkSize) {
              const chunk = content.slice(
                offset,
                Math.min(offset + chunkSize, totalSize)
              )
              await writable.write(chunk)

              const progress = Math.round(
                ((offset + chunk.byteLength) / totalSize) * 100
              )
              // 允许UI更新
              await new Promise((resolve) => setTimeout(resolve, 1))
            }
          } else {
            await writable.write(content)
          }

          await writable.close()

          const file = await fileHandle.getFile()

          await loadFileList()
          return fileHandle
        } catch (error) {
          console.error('OPFS 保存错误:', error)
          return null
        }
      }
      // 加载文件列表

      // 递归加载文件和目录列表
      const loadFileList = async (basePath = '') => {
        try {
          const targetDir = basePath
            ? await getDirectoryHandle(basePath)
            : await getOPFSRoot()
          const fileList = []
          const dirList = []

          await loadDirectoryRecursive(targetDir, basePath, fileList, dirList)
          // 按修改时间排序（最新的在前）
          fileList.sort((a, b) => b.lastModified - a.lastModified)

          // 更新统计信息
          const totalSize = fileList.reduce((sum, file) => sum + file.size, 0)
          const newStats = {
            totalFiles: fileList.length,
            totalDirectories: dirList.length,
            totalSize,
          }

          // 尝试获取存储配额信息
          if ('storage' in navigator && 'estimate' in navigator.storage) {
            try {
              const estimate = await navigator.storage.estimate()
              if (estimate.quota && estimate.usage) {
                newStats.availableSpace = estimate.quota - estimate.usage
                newStats.usedSpace = estimate.usage
              }
            } catch (quotaError) {
              // 忽略配额获取失败
            }
          }
        } catch (error) {}
      }
      // 递归加载目录内容
      const loadDirectoryRecursive = async (
        dirHandle,
        dirPath,
        fileList,
        dirList
      ) => {
        try {
          for await (const [name, handle] of dirHandle.entries()) {
            const fullPath = dirPath ? `${dirPath}/${name}` : name

            if (handle.kind === 'file') {
              const file = await handle.getFile()
              fileList.push({
                name,
                path: fullPath,
                size: file.size,
                handle: handle,
                lastModified: file.lastModified,
                type: file.type,
              })
            } else if (handle.kind === 'directory') {
              const subDirList = []
              const subFileList = []

              await loadDirectoryRecursive(
                handle,
                fullPath,
                subFileList,
                subDirList
              )

              dirList.push({
                name,
                path: fullPath,
                handle: handle,
                children: [...subFileList, ...subDirList],
              })

              // 将子文件和子目录添加到主列表
              fileList.push(...subFileList)
              dirList.push(...subDirList)
            }
          }
          console.log(fileList, '===fileList===')
        } catch (error) {
          console.warn(`加载目录 ${dirPath} 失败:`, error)
        }
      }
      // 解压zip
      const func = async () => {
        const rangeResult = await testRangeRequest(0, 1023)
        const response = await fetch(zipUrl)
        const arrayBuffer = await response.arrayBuffer()
        const zipFile = await zip.loadAsync(arrayBuffer)
        extractZipToOPFS(zipFile)
        const configFile = zip.file('config.json')
        const configContent = await configFile.async('string')
        console.log(zipFile, await getOPFSRoot(), '=======')
        // const ab = await (await fileHandle.getFile()).arrayBuffer()
        // await saveToOPFS(`extracted-config.json`, configContent)
      }

      // 新增：通过 ReadableStream 读取 OPFS 文件内容
      function createOPFSReadableStream(filename, chunkSize = 64 ) {
        let file,
          fileSize,
          offset = 0
        let fileHandle

        return new ReadableStream({
          async start(controller) {
            // 获取 OPFS 文件句柄和文件对象
            const root = await getOPFSRoot()
            fileHandle = await root.getFileHandle(filename)
            file = await fileHandle.getFile()
            fileSize = file.size
          },
          async pull(controller) {
            if (offset >= fileSize) {
              controller.close()
              window.parent.postMessage(
                { type: 'streamEnd', filename },
                'http://127.0.0.1:3001'
              )
              return
            }
            // 读取 chunk
            const end = Math.min(offset + chunkSize, fileSize)
            const blob = file.slice(offset, end)
            const chunk = await blob.arrayBuffer()
            controller.enqueue(chunk)
            window.parent.postMessage(
              { type: 'streamChunk', filename, chunk, id: 123 },
              'http://127.0.0.1:3001',
              [chunk]
            )
            offset = end
          },
          cancel() {
            // 可选：取消读取
          },
        })
      }

      // 示例：本地读取 test2.js 并输出到控制台
      async function testOPFSStreamRead() {
        const stream = createOPFSReadableStream('config.json')
        const reader = stream.getReader()
        let total = 0
        while (true) {
          const { value, done } = await reader.read()
          if (done) break
          total += value.byteLength
          console.log('读取 chunk:', value)
        }
        console.log('读取完成，总字节数:', total)
      }

      // 你可以在按钮点击时测试
      document.getElementById('test').addEventListener('click', async () => {
        await testOPFSStreamRead()
      })
      // // 测试不跨域直接获取文件
      // document.getElementById('test').addEventListener('click', async () => {
      //   // const res = await readFromOPFS('test2.js')
      //   // t1 = performance.now()
      //   // console.log(t1 - t0, res, '===直接读取===')
      //   testSmartRangeRequest()
      // })
      const OpfsAPI = {
        getOPFSRoot,
        readFromOPFS,
        excatorZip: func,
      }
      // 监听跨域消息
      window.addEventListener('message', async (evt) => {
        // 检查 source/origin...
        const { id, method, args } = evt.data
        let result, error
        if (!OpfsAPI[method]) return
        try {
          result = await OpfsAPI[method](...args)
        } catch (e) {
          error = e.message
        }
        console.log(evt.origin, evt.source, 'evt.origin')

        evt.source.postMessage({ id, result, error }, evt.origin, [result])
        console.log(result, await OpfsAPI[method](...args), '===读取===')
      })
    </script>
  </body>
</html>
